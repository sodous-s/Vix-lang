// Math library for Vix language
// Provides common mathematical functions

// Square root function - uses Newton's method approximation
fn sqrt(x: f64) -> f64 {
    if (x < 0) {
        print("Error: Cannot compute square root of negative number")
        return 0.0
    }
    if (x == 0) {
        return 0.0
    }
    
    // Initial guess
    val: f64 = x / 2.0
    
    // Newton's method iteration
    i: i32 = 0
    while (i < 20) {  // Limit iterations to prevent infinite loop
        new_val: f64 = 0.5 * (val + x / val)
        
        // Check for convergence
        diff: f64 = new_val - val
        if (diff < 0) {
            diff = -diff  // abs function simulation
        }
        
        if (diff < 1e-10) {
            break
        }
        
        val = new_val
        i += 1
    }
    
    return val
}

// Power function - computes base^exponent
fn pow(base: f64, exponent: f64) -> f64 {
    result: f64 = 1.0
    exp_int: i32 = toint(exponent)
    
    // Handle positive integer exponents
    if (exponent == exp_int && exponent >= 0) {
        i: i32 = 0
        while (i < exp_int) {
            result *= base
            i += 1
        }
        return result
    }
    
    // For other cases, use logarithms (basic implementation)
    // More advanced implementation would use better algorithms
    if (base <= 0) {
        print("Warning: Invalid base for power function")
        return 0.0
    }
    
    // Basic implementation using repeated multiplication for fractional powers
    // This is a simplified version; in practice, you'd want more sophisticated methods
    if (exponent == 0.5) {
        return sqrt(base)
    }
    
    // Default case - basic handling
    return base ** exponent  // Using built-in operator if available
}

// Absolute value function
fn abs(x: f64) -> f64 {
    if (x < 0) {
        return -x
    }
    return x
}

// Maximum of two numbers
fn max(a: f64, b: f64) -> f64 {
    if (a > b) {
        return a
    }
    return b
}

// Minimum of two numbers
fn min(a: f64, b: f64) -> f64 {
    if (a < b) {
        return a
    }
    return b
}

// Ceiling function
fn ceil(x: f64) -> f64 {
    int_part: i32 = toint(x)
    int_x: f64 = int_part
    
    if (int_x == x) {
        return x  // Already an integer
    }
    
    if (x > 0) {
        return int_x + 1.0
    } else {
        return int_x
    }
}

// Floor function
fn floor(x: f64) -> f64 {
    int_part: i32 = toint(x)
    int_x: f64 = int_part
    
    if (int_x == x) {
        return x  // Already an integer
    }
    
    if (x > 0) {
        return int_x
    } else {
        return int_x - 1.0
    }
}

// Round function
fn round(x: f64) -> f64 {
    int_part: i32 = toint(x)
    frac_part: f64 = x - int_part
    
    if (frac_part >= 0.5) {
        return int_part + 1.0
    } else if (frac_part <= -0.5) {
        return int_part - 1.0
    } else {
        return int_part
    }
}

// Constants
PI: f64 = 3.141592653589793
E: f64 = 2.718281828459045